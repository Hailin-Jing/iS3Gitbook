{"./":{"url":"./","title":"一、平台说明","keywords":"","body":"平台说明平台说明 ​ iS3(infrastructure Smart Service System)平台的目标功能是：对地下工程从前期的地质勘测数据、地形数据、环境数据、设计数据、施工数据、监测数据一直到后期的运营维护等数据进行采集、管理、可视化和分析，服务于地下工程的整个生命周期。 ​ iS3 平台以开放性、集成性与全过程性为特点，可以服务与地下工程建设的各个阶段。 ​ 本部分将对iS3平台进行相关介绍和说明。本部分共有两章，这两章分别对iS3的平台架构和界面进行了说明介绍。 平台架构 界面说明 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter1/section1.html":{"url":"chapter1/section1.html","title":"第一章 平台架构","keywords":"","body":"平台架构iS3系统总体架构iS3数据层架构工程数据角度图形数据角度工程管理角度统一数据模型数据组织iS3服务层架构iS3应用层架构平台架构 iS3系统总体架构 软件总体框架包含四层，分别是数据层、服务层、应用框架层以及应用层，如下图所示。 数据层提供数据标准格式，实现各种类型数据的对接，如BIM、GIS及各类数据库、倾斜摄影、激光扫描等数据，并支持数据的增删改查。 服务层实现数据的云存储，提供数据访问组件，通过WebAPI实现各类数据的增删改查，并提供数据的各类分析功能，如结构分析、服役性能分析、调度服务及地图服务。 应用框架层分为桌面端、Web端、移动端，桌面端已较为完善，Web端和移动端处于研发阶段。 应用层则是基于应用框架层，根据工程实际应用需求设计应用。 iS3平台以iS3 Core为基础，提供IS3数据接口、功能接口、扩展接口等一系列核心功能定义，是进行IS3二次开发的关键。 在iS3 核心框架下，iS3平台前端主要包括服务器端(iS3 Server)、桌面端(iS3 Desktop)、移动端(iS3 Mobile)和云服务端(iS3 Cloud)，做到了一套数据，一个底层平台，跨平台显示的效果。 目前iS3平台主要依托桌面端，移动端和云端也在不断的开发完善中，相关SDK也会在之后一段时间陆续发布。 iS3数据层架构 iS3平台的数据架构思路可以从工程数据、图形数据和工程管理这三个方面来进行阐述。如下图所示： 工程数据角度 地下工程结构在勘测、设计和施工过程中将涉及到众多数据，对这些数据可以做如下划分： 地质勘测数据：工程地质数据（钻孔、地层、土层特性等）、水文地质数据（潜水、承压水等） 设计数据：衬砌环设计、线路设计、车站设计等 施工数据：盾构机推进参数、推进进度等 监测数据：土压力计示数、维护墙位移、衬砌环倾角及位移等 维护管理数据：温湿度信息、灾害预警装置数据等 在iS3平台中，工程数据存储在数据库中。 图形数据角度 图形数据主要指工程相关的CAD图纸，包括工程设计阶段的各种平面图、横剖面图、纵剖面图和三维视图等。这类数据是对工程的最直观显示，含有地下工程结构的详细尺寸数据等信息。同时，后期也将以这些CAD图纸为依据对地下建筑工程进行三维建模，实现工程的三维可视化。 iS3平台中，在考虑CAD数据要跟数据库中工程数据分类合理关联的基础上对CAD图层进行编辑，然后导入到ArcGIS软件，以ArcGIS图层的形式存储CAD数据。此外，平台还需要配置地图数据作为地下结构工程的底图，为了获得良好的用户体验，同时又保证满足精度要求，将底图制作成切片以减小地图缩放时的内存占用。 工程管理角度 从对工程的管理角度来看，项目中不同的角色将对iS3平台提出不同的功能需求：项目业主的领导层比较关注工程的整体施工进度，以及工程是否安全顺利；项目经理的关注重点是本项目标段的进度如何；施工队伍比较关注下一个施工段前方的地质条件情况如何，施工是否安全等。现阶段，iS3平台的工程管理视图功能在不断开发中。 统一数据模型 iS3平台将不同数据类型的数据整合在一起，形成了一个统一的数据模型，如下图所示： 数据组织 iS3平台将不同项目以Project划分，每个Project之下分为不同Domain（域），其中有很多DGObjects（数字化对象组），每个DGObjects是许多DGObject（数字化对象）的集合。 上图中： 蓝色块的含义：平台专有概念对应的类； 橙色块和黄色块的含义：该类下的成员。 iS3服务层架构 服务层是为应用层提供数据访问接口、分析服务接口的逻辑层，由iS3服务端 (iS3 Server) 提供。服务层一方面简化、统一了数据访问的方式和底层硬件设备的调用方式，另一方面则保证了数据的安全性，不被随意访问、改动和删除。 服务层根据分析目标的不同，采取不同的分析手段进行分析，包括：数学分析、空间分析、数字--数值一体化分析、大数据分析、云计算等等。 空间分析是在数据模型的基础上，基于二维、三维几何属性，提取空间上有用信息，找出数据在空间上的规律与联系，其中二维空间分析包括范围查询、长度面积测量、空间变换和网络优化等，三维空间分析则包括土方填挖方分析、隧道剖面分析、地质剖面分析、几何空间碰撞分析等。数字-数值一体化分析的基本思路是在iS3中，以数字模型为基础，获取数值分析数据，如几何属性、材料数据、荷载数据等，并自动化生成数值分析前处理模型，通过数据文件在有限元数值软件中完成分析工作，最后再将计算结果传回iS3系统。 由于决策与服务与具体的工程应用需求相关，因此服务对象的不同，服务的内容与所需要决策的内容也就不同。iS3是一个开源的、开放的平台，用户可以针对自己的需求，构建满足决策与应用的专业服务模块。为了拓展服务层的服务功能范围，iS3在统一数据模型的基础上，提供了对外开放的、可扩展的数据接口，并提供了二次开发的案例作为参考，为分析功能的定制与开发奠定了坚实的基础。 iS3应用层架构 平台将跨平台推出客户端，包括桌面端、Web端以及移动端。工程用户（建设方、勘查方、设计方、施工方、监理方）在不同的应用场景下选择适合的客户端对项目进行管理，如上图所示。 根据的用户权限，平台会对用户开放相应的服务，包括数据服务、GIS服务以及BIM服务，并支持用户自行构建满足决策与应用的专业服务模块。 为了拓展云服务的服务功能范围，平台在统一数据模型的基础上，提供了对外开放的、可扩展的数据接口，为分析功能的定制与开发奠定了坚实的基础。 用户在调用GIS服务和BIM服务的时候，通过iS3云服务中的数据服务，可根据用户权限对相应模块的数据进行操作，实现管理工程的协同工作。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter1/section2.html":{"url":"chapter1/section2.html","title":"第二章 界面说明","keywords":"","body":"界面说明服务器连接配置界面平台登录界面工程选择界面工程主界面工程主界面详细介绍界面说明 本章以TONGJI项目为例。 点击桌面图标基础设施智慧服务系统（iS3），运行 iS3 平台。 服务器连接配置界面 点击系统配置，可配置服务地址以及服务端口。 平台登录界面 在登录界面，输入账号、密码（默认账号：Admin，默认密码：Admin），点击用户登录，即可登录平台。 工程选择界面 点击左边工程列表或点击右边地图图标均可选择相应工程，右键点击地图上图标，选择进入工程，进入工程主界面。 工程主界面 点击主界面二维、三维或者数据表，均可选择相应对应并进行数据查看。 工程主界面详细介绍 ①代表：二三维展示区 ②代表：分别为 Python 编译器和数据表格区 ③代表：工程数据列表区 ④代表：分别为对象信息查看区和拓展工具区 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/":{"url":"chapter2/","title":"二、平台使用","keywords":"","body":"平台使用平台使用 本部分将对iS3平台的使用进行介绍，并以TONGJI项目为例，详细解释了用户应该如何将自己的数据部署到iS3平台上来。 使用平台前，需先下载平台Server端、Client端源码及TONGJI样例项目需使用的数据文件。下载链接：https://pan.baidu.com/s/1Drz0JPHqaGZ8Bd8kLFS2JQ 。提取码：7umc。 本部分分为四章，数据准备是基础，之后进行server端准备，最后进行client端准备。Python接口与平台的二次开发有关，有此方面需求的用户可以进行相关配置。 数据准备 server端准备 client端准备 Python接口 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1.html":{"url":"chapter2/section1.html","title":"第一章 数据准备","keywords":"","body":"数据准备数据准备 本章将向用户介绍的是使用iS3平台时，所需要准备的数据，以便用户更快速地上手使用iS3平台。 本章分为两节，包括用户对数据库进行配置，以及本地的数据配置。本地数据配置中的数据文件准备(二、平台使用/第一章 数据准备/第二节 本地数据配置/1. 数据文件准备)的理论知识可以参考平台架构(一、平台说明/第一章 平台架构)中的iS3数据层架构的内容。 数据库配置 数据库说明 表的创建 server端的配置 本地数据配置 数据文件准备 配置文件生成 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part2.html":{"url":"chapter2/section1/part2.html","title":"第一节 数据库配置","keywords":"","body":"数据库配置数据库配置 本节对数据库的配置进行相关介绍和说明。 本节分为三个小节，分别解释说明了iS3平台的可用数据库，数据库的建表原则，以及如何将数据库与项目连接起来。 数据库说明 表的创建 server端的配置 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part2/detail1.html":{"url":"chapter2/section1/part2/detail1.html","title":"1. 数据库说明","keywords":"","body":"数据库说明数据库说明 本平台只适用于SQL Server数据库。 SQL Server 是微软公司推出的关系型数据库管理系统。具有使用方便、可伸缩性好、与相关软件集成程度高等优点。 Microsoft SQL Server 是一个全面的数据库平台，使用集成的商业智能工具提供了企业级的数据管理。Microsoft SQL Server 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能，使用户可以构建和管理用于业务的高可用和高性能的数据应用程序。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part2/detail2.html":{"url":"chapter2/section1/part2/detail2.html","title":"2. 表的创建","keywords":"","body":"表的创建iS3AreaHandle类建表表的创建 iS3AreaHandle类 iS3平台设定每张表的实体类都继承 .\\iS3.MiniServer\\iS3.Core\\iS3Core.cs文件中的 iS3AreaHandle类，换言之，在不改变这个类的内容的情况下，每张表都要有其中的 object_id ID Name Description FullName 这五列，数据类型也在类iS3AreaHandle中有注明，其余列名用户可根据自己的数据对应命名。当然用户也可以根据自己数据的特点对 iS3AreaHandle类进行修改，相应地，表的公共属性也进行对应的改变。 建表 Entity Framework Code First与数据表之间有两种映射方式（详见EFCF属性映射约定(三、附录/第一章 EFCF属性映射约定 )），选择某一种或两种方式兼用也可，根据不同方式创建表名。 在远程数据库与在Server端App.config文件（详见server端的配置(二、平台使用/第一章 数据准备/第一节 数据库配置/3. server端的配置)）里添加的库名一致的数据库中建表并导入与配置文件geodatabase相对应的数据。表名应与对应的DGObject在Server端的Model文件里的Table表名保持一致，且表名前缀应与GeologyContext.cs文件里的TablePrefix保持一致。 以borehole为例，Geology_Borehole DDL如下： create table Geology_Borehole( #以下是对borehole属性的定义，左边一列是属性，右边一列是属性的数据类型 object_id int not null, ID int, Name varchar(20) not null constraint Geology_Borehole_pk primary key nonclustered, FullName nvarchar(max) not null, Description nvarchar(max), #以上是 iS3AreaHandle 类中定义的属性，下面是borehole自身的属性 StratumSection int, SectionSequence int, BoreholeType nvarchar(max) not null, TopElevation float not null, BoreholeLength float not null, Mileage nvarchar(max), Xcoordinate float, Ycoordinate float, OBJECTID nvarchar(max) ) go © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part2/detail3.html":{"url":"chapter2/section1/part2/detail3.html","title":"3. server端的配置","keywords":"","body":"server端的配置server端的配置 在.\\iS3.MiniServer\\iS3.MiniServer\\App.config中添加新加项目的数据库信息。 以TONGJI项目为例，在 里添加TONGJI项目的数据库信息。 本例中： TS_iS3_V2 数据库中定义了Project的信息(含义参考平台架构(一、平台说明/第一章 平台架构)中的数据组织)，其中的Project_ProjectLocation表包含所有可以在iS3平台加载的项目简要信息，如项目名称、ID、描述等（此处大致理解，具体内容可以在完成本地数据配置(二、平台使用/第一章 数据准备/第二节 本地数据配置)步骤后参考添加项目到数据库(二、平台使用/第一章 数据准备/第二节 本地数据配置/3. 添加项目到数据库)）。 TS_iS3_V2_Test 数据库中定义了不同DGObject的信息(含义参考平台架构(一、平台说明/第一章 平台架构)中的数据组织)。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part1.html":{"url":"chapter2/section1/part1.html","title":"第二节 本地数据配置","keywords":"","body":"本地数据配置本地数据配置 本节对本地数据的配置进行相关介绍和说明。其中的数据文件准备(二、平台使用/第一章 数据准备/第二节 本地数据配置/1. 数据文件准备)的理论知识可以参考平台架构(一、平台说明/第一章 平台架构)中的iS3数据层架构的内容。 本节分为2个小节，详细说明了用户可将哪些类型的数据放入项目，并在使用配置工具（.\\iS3-Desktop-Client\\Output\\iS3.Config.exe）时如何配置相关数据的路径。 数据文件准备 配置文件生成 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part1/detail1.html":{"url":"chapter2/section1/part1/detail1.html","title":"1. 数据文件准备","keywords":"","body":"数据文件准备step1step2step3数据文件准备 本小节涉及的数据类型的介绍详见平台架构(一、平台说明/第一章 平台架构)中的iS3数据层架构的内容。 step1 在.\\iS3-Desktop-Client\\Output\\Data路径下新建名为项目名称的文件夹，并在该文件夹下加入geodatabase ,py,unity3d三个数据文件。 以TONGJI项目为例，在.\\iS3_2.0_Demo-master\\iS3-Desktop-Client\\Output\\Data路径下新建TONGJI的文件夹，在该文件夹下加入tongji.geodatabase,TONGJI.py,tongji.unity3d三个数据文件。 step2 在.\\iS3-Desktop-Client\\Output\\Data\\TPKs文件夹下加入tpk文件。 以TONGJI项目为例，在.\\iS3-Desktop-Client\\Output\\Data\\TPKs文件夹下加入tongji.tpk文件。 step3 运行iS3.Config.exe。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part1/detail2.html":{"url":"chapter2/section1/part1/detail2.html","title":"2. 配置文件生成","keywords":"","body":"配置文件生成步骤概览Preparation Step 1 -- 配置iS3及数据目录的路径Preparation Step 2 -- 配置项目地点和表述信息Step 1 -- 基本信息配置Step 2 -- 2D模型配置（地图引擎配置）Step 3 -- 配置项目的Domains信息Step 4 -- 配置项目树配置完成配置文件生成 步骤概览 Preparation Step 1：配置iS3及数据目录的路径 Preparation Step 2：配置项目地点和表述信息 Step 1 ：基本信息配置 Step 2：2D模型配置（地图引擎配置） Step 3：配置项目的Domains信息 Step 4 ：配置项目树 配置完成 Preparation Step 1 -- 配置iS3及数据目录的路径 配置iS3的运行路径（即iS3.Config.exe所在文件夹路径）和数据目录的路径（即数据文件准备（二、平台使用/第一章 数据准备/第二节 本地数据配置/1.数据文件准备）中存储项目数据文件和TPKS文件的文件夹路径）。默认情况下不用更改。 点击Start configuration按钮开始配置。 Preparation Step 2 -- 配置项目地点和表述信息 配置该项目的名称，项目地点和表述信息。 点击加号按钮，添加项目，填写项目ID和描述信息。 选中新建的项目项，点击Location，在地图上选择项目的地点并点击。 如果想要修改描述信息，选中要修改的项目项，点击Description，可以对描述信息进行修改。 配置好后点击Next按钮。 Step 1 -- 基本信息配置 ID为项目ID，Title为项目名，Local data path为数据文件准备（二、平台使用/第一章 数据准备/第二节 本地数据配置/1.数据文件准备）中存储项目数据文件，Local tile path为数据文件准备中TPKS文件的文件夹路径。这二者默认情况下无需更改。Database为数据库地址，分别替换掉IP地址、数据库名称、用户名称和密码。 配置好后点击Next按钮。 Step 2 -- 2D模型配置（地图引擎配置） 点击左侧栏下方的添加按钮创建新的地图。 在右边栏填写地图ID（默认ID为Map0），选择地图类型（默认类型为FootPrintMap)。 以TONGJI项目为例，地图ID为Map0，地图类型为FootPrintMap。 点击右侧栏Local tiled map的按钮，选择该项目要使用的tpk文件。 点击右侧栏Local GeoDB file的按钮，选择该项目要用的geodatabase文件，并可以在Geo Layers里勾选要用的图层。 配置好后点击Next按钮。 Step 3 -- 配置项目的Domains信息 点击左上角Domains栏下的添加按钮，在弹出的对话框里选择要选择的Domain类型。 如下图，选择Geology类。 选中要添加的Objects所属的Domain，点击左下角Digital objects栏下的添加按钮，在弹出的对话框里填写该Objects的名字。 选中要进行配置的Domain和Digital object，在右侧选择该Digital object的类型。 填写Table name。点击Table name右侧的按钮，打开对话框，选择数据对应的表名。如图所示，此例选择Geology_Borehole。 还可以对该表进行sql语句查询，即在Condition(SQL)项输入查询条件，在Order(SQL)项输入查询的数据以哪个属性排序。如图所示，查询OBJECTID大于3的数据，按Name排序。 点击Preview Table按钮。 如果该Digital object有对应的2D模型，则勾选Has 2D Model项，并点击其右侧的文件选择按钮，选择其对应的模型图层。 如果没有对应模型，则可以不勾选。 如下图所示，Allboreholes对应的2D模型为Map0的Borehole层。完成后点击OK。 完成后可以点击下方按钮Preview 2D Layer...进行查看。 如果该Digital object有对应的3D模型，则勾选Has 3D Model项，并点击其右侧的文件选择按钮，选择其对应的模型图层。 如果没有对应模型，则可以不勾选。 如下图所示，Allboreholes对应的2D模型为Borehole层。完成后点击OK。 完成后可以点击下方按钮Preview 3D Model...进行查看。 配置好后点击Next按钮。 Step 4 -- 配置项目树 在左侧栏下方选中Domain，在左侧栏空白处点击鼠标右键，选择Add添加树。 填写根的Name和Display Name。 选中根项点击右键添加Digital object，并填写Display Name，选择Name和Digital object。 注意：在切换Domain的标签前，务必先选中切换前Domain的根项，否则选中项的Digital object属性会丢失。 配置好后点击Finish按钮。 配置完成 配置成功后会弹出对话框如下图。 在.\\iS3-Desktop-Client\\Output\\Data路径下也会生成一个项目配置文件。在该例中，出现TONGJI.xml文件。内容如下： 项目配置文件如若理解透彻，也可以自己手动编写。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section1/part1/detail3.html":{"url":"chapter2/section1/part1/detail3.html","title":"3. 添加项目到数据库","keywords":"","body":"添加项目到数据库添加项目到数据库 新创建的项目信息需要添加到数据库中，才能在iS3平台访问并使用。 项目信息应被添加到数据库TS_iS3_V2的工程列表中（表名为Project_ProjectLocation）。 如果数据库中不存在该表，首先应该添加这张表。 建表的DDL如下： create table Project_ProjectLocation ( #编号，主码 object_id int identity constraint [PK_dbo.Project_ProjectLocation] primary key, #项目代号，即为配置文件XML中的项目ID CODE nvarchar(max), #项目名称，即为配置文件XML中的项目名称 ProjectTitle nvarchar(max), #横坐标 X decimal(18, 2), #纵坐标 Y decimal(18, 2), #项目描述 Description nvarchar(max), #ID，按顺序添加即可 ID int not null, Name nvarchar(max), FullName nvarchar(max) ) go 建表成功后，向表中添加数据。 可以将上一步配置文件时生成的ProjectList.xml作为辅助工具，将其中记录的数据一一填入数据库。 如在本例中，生成的ProjectList.xml中的里的这条数据： 添加到数据库后： 添加后，提交更新。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section2.html":{"url":"chapter2/section2.html","title":"第二章 server端准备","keywords":"","body":"server端准备server端准备 本章将介绍用户在完成数据准备(二、平台使用/第一章 数据准备)之后，对server端进行的操作。 首先用户需要添加自己数据中的数据对象DGObject模型，然后需要配置对应的接口以供client端访问。 本章以TONGJI项目为例，该项目有Geology和Monitoring两个Domain（详见平台架构(一、平台说明/第一章 平台架构)中的iS3数据层架构），在这两节中，将按照不同Domain分别举例说明。 数据配置 API配置 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section2/server1.html":{"url":"chapter2/section2/server1.html","title":"第一节 数据配置","keywords":"","body":"数据配置GeologyMonitoring数据配置 平台根据数据用途将数据分为多个Domain类，在这里我们以地质数据Geology和监测点数据Monitoring为例，介绍Domain类下数据对象DGObject模型的配置方法。 其中，Geology和Monitoring运用了EntityFramework映射中的Data Annotation方式（详见EFCF属性映射约定(三、附录/第一章 EFCF属性映射规定)） Geology Geology的数据放在.\\iS3.MiniServer\\iS3.Geology\\Model中，其中记录着表的属性和对应的数据类型。（不包括类iS3AreaHandle中的五个属性及其数据类型，关于类iS3AreaHandle详见表的创建(二、平台使用/第一章 数据准备/第一节 数据库配置/2. 表的创建)中的 iS3AreaHandle类） 以borehole.cs（钻孔）为例： using System; using System.Collections.Generic; using System.ComponentModel.DataAnnotations.Schema; using System.Linq; using System.Text; using System.Threading.Tasks; using iS3.Core; namespace iS3.Geology.Model { //指定表名为\"Geology_Borehole\" [Table(\"Geology_Borehole\")] public partial class Borehole:iS3AreaHandle { //以下是表\"Geology_Borehole\"的属性及其对应的数据类型 //{ get; set; } get 是读取属性时进行的操作，set 是设置属性时进行的操作。 public string OBJECTID { get; set; } public string Name { get; set; } public string FullName { get; set; } public string Description { get; set; } public Nullable StratumSection { get; set; } public Nullable SectionSequence { get; set; } public string BoreholeType { get; set; } public double TopElevation { get; set; } public double BoreholeLength { get; set; } public string Mileage { get; set; } public Nullable Xcoordinate { get; set; } public Nullable Ycoordinate { get; set; } //NotMapped特性可以应用到领域类的属性中，EF Code-First默认的约定:为所有带有get,和set属性选择器的属性创建数据列。 //而NotManpped特性打破了这个约定，你可以使用NotMapped特性到某个属性上面，然后Code-First就不会为这个属性在数据表中创建列了。 [NotMapped] public List BoreholeStratas { get; set; } = new List(); } } Monitoring Monitoring的数据放在.\\iS3.MiniServer\\iS3.Monitoring\\Model中，其中记录着表的列名（不包括类iS3AreaHandle中的五个列名）和数据类型。 以monpoint.cs（监测点）为例： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using iS3.Core; using System.ComponentModel.DataAnnotations.Schema; namespace iS3.Monitoring { //未指定表名，所以表名为默认\"MonPoint\"复数形式：MonPoints\" //以下是表\"Monpoints\"的属性及其对应的数据类型 //{ get; set; } get 是读取属性时进行的操作，set 是设置属性时进行的操作。 public class MonPoint: iS3AreaHandle { // Summary: // reference point name public string refPointName { get; set; } // Summary: // distance to the reference point public Nullable distanceX { get; set; } public Nullable distanceY { get; set; } public Nullable distanceZ { get; set; } // Summary: // Installation date and time public Nullable time { get; set; } // Summary: // Instrument detail public string instrumentDetail { get; set; } // Summary: // Bearing of monitoring axis (A, B, C): in degree public Nullable bearingA { get; set; } public Nullable bearingB { get; set; } public Nullable bearingC { get; set; } // Summary: // Inclination of instrument axis (A, B, C): in degree public Nullable inclinationA { get; set; } public Nullable inclinationB { get; set; } public Nullable inclinationC { get; set; } // Summary: // Reading sign convention in direction (A, B, C) public string readingSignA { get; set; } public string readingSignB { get; set; } public string readingSignC { get; set; } // Summary: // componennt count public int componentCount { get; set; } // Summary: // Component names public string componentNames { get; set; } // Summary: // Remarks public string remarks { get; set; } // Summary: // Contractor who installed monitoring instrument public string contractor { get; set; } // Summary: // Associated file reference public string fileName { get; set; } //NotMapped特性可以应用到领域类的属性中，EF Code-First默认的约定:为所有带有get,和set属性选择器的属性创建数据列。 //而NotManpped特性打破了这个约定，你可以使用NotMapped特性到某个属性上面，然后Code-First就不会为这个属性在数据表中创建列了。 [NotMapped] // Summary: // readings dictionary - reading component indexed public Dictionary> readingsDict; [NotMapped] public List monComponentList; } } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section2/server2.html":{"url":"chapter2/section2/server2.html","title":"第二节 API配置","keywords":"","body":"API配置GeologyMonitoringAPI配置 API配置用于给Client端的访问提供接口并返回数据。 Geology 1.Geology类型的数据需要在.\\iS3.MiniServer\\iS3.MiniServer\\GeologyController.cs中增加API名称和调用方法。 以钻孔borehole的API为例： ①通过getBoreholeById()方法，根据id获取工程钻孔数据 // //根据id获取工程钻孔数据 // //项目名称 //钻孔id [Route(\"borehole\")] [HttpGet] public Borehole getBoreholeById(string project, int id) { var repo = RepositoryForServer.GetInstance(project); return repo.Retrieve(id).Result; } ②通过getBoreholeByObjs()方法，根据对象组获取工程钻孔数据 /// /// 根据对象组获取钻孔 /// /// /// /// /// [Route(\"borehole\")] [HttpGet] public List getBoreholeByObjs(string project, int objsid, string filter) { var repo = RepositoryForServer.GetInstance(project); return repo.RetrieveByObjs(objsid, filter).Result; } [Route(\"borehole\")] [HttpGet] public List getBoreholeList(string project) { var repo = new RepositoryForServer(project); return repo.RetrieveAll().Result; } ③通过postBorehole()方法，新增钻孔对象 /// /// 新增borehole对象,连带其中的钻孔地层对象，如果有的话 /// /// /// /// [Route(\"borehole\")] [HttpPost] public Borehole postBorehole([FromUri]string project, [FromBody]Borehole model) { var repo = RepositoryForServer.GetInstance(project); return repo.Create(model).Result; } ④通过putBorehole()方法，更新钻孔信息 /// /// 更新钻孔信息，不更新其中的钻孔地层对象信息 /// /// /// /// [Route(\"borehole\")] [HttpPut] public Borehole putBorehole([FromUri]string project, [FromBody]Borehole model) { var repo = RepositoryForServer.GetInstance(project); return repo.Update(model).Result; } ⑤通过deleteBorehole()方法， 删除钻孔对象 /// /// 删除钻孔对象，同时删除对应的钻孔地层对象 /// /// /// /// [Route(\"borehole\")] [HttpDelete] public int deleteBorehole([FromUri]string project, [FromBody]Borehole model) { var repo = RepositoryForServer.GetInstance(project); return repo.Delete(model).Result; } 2.在.\\iS3.MiniServer\\iS3.Geology.Server\\GeologyContext.cs中加入获取表内信息的代码，以钻孔的表为例： public virtual DbSet Borehole { get; set; } 3.在.\\iS3.MiniServer\\iS3.Geology\\GeologyContext.cs中加入获取表内信息的代码，以钻孔为例： public virtual DbSet Borehole { get; set; } 以及API名称和调用方法，以getBoreholeById()方法为例： // // 根据id获取工程钻孔数据 // //项目名称 //钻孔id [Route(\"borehole\")] [HttpGet] public Borehole getBoreholeById(string project, int id) { //通过getBoreholeById()方法获取数据 var repo = RepositoryForServer.GetInstance(project); return repo.Retrieve(id).Result; } Monitoring 1.Monitoring类型的数据需要在.\\iS3.MiniServer\\iS3.MiniServer\\ MonitoringController.cs中增加API名称和调用方法。 以监测点monpoint的API为例： ①通过getMonPointListByObjsID()方法，根据objsid获取工程监测点数据 [Route(\"monpoint\")] [HttpGet] public List getMonPointListByObjsID(string project, int objsid, string filter) { var repo = new RepositoryForServer(project); return repo.RetrieveAll().Result; } ②通过getMonPointByID()方法，根据id获取工程监测点数据 [Route(\"monpoint\")] [HttpGet] public MonPoint getMonPointByID(string project, int id) { var repo = new RepositoryForServer(project); MonitoringContext monContext = repo.context as MonitoringContext; MonPoint mp = monContext.MonPoint.Where(x => x.ID == id).FirstOrDefault(); if (mp == null) return null; mp.monComponentList = new List(); List componentNameList = mp.componentNames.Split(',').ToList(); foreach (string key in componentNameList) { mp.monComponentList.Add(new MonComponent() { componentName = key, readings = monContext.MonReading.Where(x => ((x.monPointName == mp.Name) && (x.component == key))).ToList() }); } return mp; } ③通过postMonPoint()方法，新增监测点对象 /// /// /// [Route(\"monpoint\")] [HttpPost] public MonPoint postMonPoint([FromUri]string project, [FromBody]MonPoint model) { var repo = RepositoryForServer.GetInstance(project); return repo.Create(model).Result; } ④通过putMonPoint()方法，更新监测点信息 /// /// /// [Route(\"monpoint\")] [HttpPut] public MonPoint putMonPoint([FromUri]string project, [FromBody]MonPoint model) { var repo = RepositoryForServer.GetInstance(project); return repo.Update(model).Result; } ⑤通过deleteMonPoint()方法， 删除监测点对象 /// /// /// [Route(\"monpoint\")] [HttpDelete] public int deleteMonPoint([FromUri]string project, [FromBody]MonPoint model) { var repo = RepositoryForServer.GetInstance(project); return repo.Delete(model).Result; } 2.在.\\iS3.MiniServer\\iS3.Monitoring\\MonitoringContext.cs中加入获取表内部信息的代码，以监测点MonPoint的表为例： public virtual DbSet MonPoint { get; set; } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3.html":{"url":"chapter2/section3.html","title":"第三章 client端准备","keywords":"","body":"client端准备client端准备 本章将介绍用户在完成数据准备(二、平台使用/第一章 数据准备)，server端准备(二、平台使用/第二章 server端准备)之后，对client端进行的操作。 本章分为三节，分别对数字化对象实体类的自定义，二次开发C#接口以及工具面板的拓展进行介绍。本章是iS3 工程项目配置的最后一个环节，本章的末尾你将得到一个可以运行的iS3项目。 自定义数字化对象 1. 创建拓展项目 2. 实现数字化对象实体类 3. 定义拓展类入口 4. 修改运行配置 C#接口文档 常用接口 数据调用接口 拓展工具面板 简要说明 开发过程 © Tongji University all right reserved，File Modify: 2020-01-30 01:02:20 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part1.html":{"url":"chapter2/section3/part1.html","title":"第一节 自定义数字化对象","keywords":"","body":"自定义数字化对象自定义数字化对象 DGObject类是数据对象基类，用于存储工程项目涉及的地质数据信息。以MonPoint 监测点类为例，该类继承自DGObject基类，存储与监测点有关的数据信息，如参考点（refPointName）、与参考点的距离(distanceX,distanceY,distanceZ)等。一个DGObject实体通常对应实际的数据库表中的一行数据。 iS3平台提供了一些数字化对象实体类，如MonPoint类，Borehole类等。但已有的数字化对象实体类可能还不足以满足用户特定使用场景下的需求。为此，我们以Borehole类的实现为例，详细介绍自定义数字化对象类的方法。本节分为4个步骤，分别说明用户如何创建拓展项目、实现自定义数字化对象类、定义拓展类入口以及修改运行配置。 本节的末尾你将得到一个自定义的数字化对象实体类（样例为Borehole钻孔类，存储与钻孔地层图有关的数据信息）。 1.创建拓展项目 2.实现数字化对象实体类 3.定义拓展类入口 4.修改运行配置 © Tongji University all right reserved，File Modify: 2020-01-29 11:33:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part1/detail1.html":{"url":"chapter2/section3/part1/detail1.html","title":"1. 创建拓展项目","keywords":"","body":"创建拓展项目创建拓展项目 自定义数字化对象类（此处为地质数据类），首先需要在iS3-Desktop-Client/IS3-Extensions路径下新建一个名为IS3-Geology的解决方案，用于存放与自定义地质数据类有关的文件。以Visual Studio 2017的运行环境为例，此处将演示如何创建IS3-Geology地质数据拓展项目。 在Visual Studio里选择 文件->新建->项目，打开 新建项目示例，选择 其他语言-> Visual C＃-> Windows经典桌面->类库（.NET Framework），名称为“ iS3-”加域名（此处为iS3-Geology），路径为iS3-Desktop-Client/IS3-Extensions。如果域名不以iS3-开头，项目会启动失败。 创建结果如下图所示。创建完毕后，用户将在该项目下添加各种文件，如EntryPoint类、自定义的数字化对象等。具体需要添加的文件将在后面小节进行介绍。 待添加完各种所需的文件后，该项目的最终目录结构如下所示： 文件说明： EntryPoint.cs：该类是拓展库的入口。 Borehole.cs等：这些类是实现具体数据对象的类，继承自DGObject类。 IS3-Geology.csproj：该文件是新建项目时生成的C#项目文件。 其他：数据对象类功能实现的辅助类。 © Tongji University all right reserved，File Modify: 2020-01-30 01:27:44 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part1/detail2.html":{"url":"chapter2/section3/part1/detail2.html","title":"2. 实现数字化对象实体类","keywords":"","body":"实现数字化对象实体类实现数字化对象实体类 数字化对象实体类就是所需实现的扩展类，也是在项目中要被渲染出来的类，诸如钻孔信息，土质信息等。该类的实现需要继承自iS3.Core中的数字化对象基类，即DGObject。这些类需要有一些属性和基本的ToString方法和idFilter方法，此外，还可以有为渲染chartViews而进行准备的数据处理方法。 此处，我们以Borehole钻孔类为例进行介绍。 1. 属性部分 在DGObject基类中，我们定义了部分通用的属性，如_id、_name、_fullname等。但这些属性无法满足个性化的需求，对于特定的数字化对象实体，我们需要在对应类中声明其拥有的属性，并通过get、set方式与数据库中的数据建立映射关系。这些属性将会在iS3平台中展示，或者在该类定义的函数中被调用。 Borehole类的属性如下所示： 序号 属性名称 属性类型 简要说明 1 Top double 钻孔顶部高度 2 Base double 钻孔底部高度 3 Mileage double? 钻孔里程数 4 Type string 类型 5 Geologies List 钻孔内地层序列 6 StratumSection Nullable 地层剖面 7 SectionSequence Nullable 剖面序列 8 BoreholeType string 钻孔类型 9 TopElevation double 最高海拔 10 BoreholeLength double 钻孔长度 11 Xcoordinate Nullable X轴坐标 12 Ycoordinate Nullable Y轴坐标 代码定义如下： //自定义的属性值，通过get、set方式与数据库中的数据建立映射 public double Top { get; set; } public double Base { get; set; } public double? Mileage { get; set; } public string Type { get; set; } public List Geologies { get; set; } public Nullable StratumSection { get; set; } public Nullable SectionSequence { get; set; } public string BoreholeType { get; set; } public double TopElevation { get; set; } public double BoreholeLength { get; set; } public Nullable Xcoordinate { get; set; } public Nullable Ycoordinate { get; set; } 最终结果中将会在Data List板块展示Borehole类定义的上述属性数据（具体数据由数据库提供），如下图所示： 2. 函数部分 自定义数字化对象实体类时，需对DGOject基类的方法进行重载，在此也可以自定义有关函数（此处不做演示）。 序号 方法名称 传入参数 返回类型 简要说明 1 Borehole void Borehole 初始化Borehole类 2 ToString void string 重载Tostring类，即定义Borehole类的字符串输出格式 3 idFilter IEnumerable objs string 返回Borehole类型的数据集合中所有对象的ID 4 chartViews IEnumerable objs, double width, double height List 重载chartView图表视窗 代码实现如下： //初始化Borehole类 public Borehole() { Geologies = new List(); } //重载Tostring类，即定义Borehole类的字符串输出格式 public override string ToString() { string str = base.ToString(); string str1 = string.Format( \", Top={0}, Base={1}, Mileage={2}, Type={3}, Geo=\", Top, Base, Mileage, Type); str += str1; foreach (var geo in Geologies) { str += geo.StratumID + \",\"; } return str; } //返回Borehole类型的数据集合中所有对象的ID string idFilter(IEnumerable objs) { string sql = \"BoreholeID in (\"; foreach (var obj in objs) { sql += obj.ID.ToString(); sql += \",\"; } sql += \")\"; return sql; } //重载chartView图表视窗 public override List chartViews( IEnumerable objs, double width, double height) { //新建图表对象列表 List charts = new List(); //新建Borehole数组，将objs集合中的DGObject对象放入 List bhs = new List(); foreach (Borehole bh in objs) { if (bh != null && bh.Geologies.Count > 0) bhs.Add(bh); } //定位Geology类型的Domain Domain geologyDomain = Globals.project.getDomain(DomainType.Geology); //查找Geology Domain下所有Stratum类型的数字化对象，并得到一个数组 DGObjectsCollection strata = geologyDomain.getObjects(\"Stratum\"); //新建Borehole集合视图，并对其属性进行定义 BoreholeCollectionView bhsView = new BoreholeCollectionView(); bhsView.Name = \"Geology\"; bhsView.Boreholes = bhs; bhsView.Strata = strata; bhsView.ViewerHeight = height; //刷新视图 bhsView.RefreshView(); bhsView.UpdateLayout(); charts.Add(bhsView); return charts; } 3. 辅助类 3.1 BoreholeGeology 简要说明 钻孔内地层，涉及Borehole图表视窗的图形渲染。 实现代码 public class BoreholeGeology { public double Top { get; set; }//顶部高度 public double Base { get; set; }//底部高度 public int StratumID { get; set; }//地层序号 } 4. 源代码 Borehole.cs的完整源代码如下： namespace iS3.Geology { //钻孔内地层，涉及Borehole图表视窗的图形渲染。 public class BoreholeGeology { public double Top { get; set; }//顶部高度 public double Base { get; set; }//底部高度 public int StratumID { get; set; }//地层序号 } // 自定义的数字化对象类，需继承自DGObject public class Borehole : DGObject { //自定义的属性值，通过get、set方式与数据库中的数据建立映射 public double Top { get; set; } public double Base { get; set; } public double? Mileage { get; set; } public string Type { get; set; } public List Geologies { get; set; } public Nullable StratumSection { get; set; } public Nullable SectionSequence { get; set; } public string BoreholeType { get; set; } public double TopElevation { get; set; } public double BoreholeLength { get; set; } public Nullable Xcoordinate { get; set; } public Nullable Ycoordinate { get; set; } //初始化Borehole类 public Borehole() { Geologies = new List(); } //重载Tostring类，即定义Borehole类的字符串输出格式 public override string ToString() { string str = base.ToString(); string str1 = string.Format( \", Top={0}, Base={1}, Mileage={2}, Type={3}, Geo=\", Top, Base, Mileage, Type); str += str1; foreach (var geo in Geologies) { str += geo.StratumID + \",\"; } return str; } //返回Borehole类型的数据集合中所有对象的ID string idFilter(IEnumerable objs) { string sql = \"BoreholeID in (\"; foreach (var obj in objs) { sql += obj.ID.ToString(); sql += \",\"; } sql += \")\"; return sql; } //重载chartView图表视窗 public override List chartViews( IEnumerable objs, double width, double height) { //新建图表对象列表 List charts = new List(); //新建Borehole数组，将objs集合中的DGObject对象放入 List bhs = new List(); foreach (Borehole bh in objs) { if (bh != null && bh.Geologies.Count > 0) bhs.Add(bh); } //定位Geology类型的Domain Domain geologyDomain = Globals.project.getDomain(DomainType.Geology); //查找Geology Domain下所有Stratum类型的数字化对象，并得到一个数组 DGObjectsCollection strata = geologyDomain.getObjects(\"Stratum\"); //新建Borehole集合视图，并对其属性进行定义 BoreholeCollectionView bhsView = new BoreholeCollectionView(); bhsView.Name = \"Geology\"; bhsView.Boreholes = bhs; bhsView.Strata = strata; bhsView.ViewerHeight = height; //刷新视图 bhsView.RefreshView(); bhsView.UpdateLayout(); charts.Add(bhsView); return charts; } } } 5. 最终效果 完成后的最终效果图如下所示： © Tongji University all right reserved，File Modify: 2020-01-29 13:26:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part1/detail3.html":{"url":"chapter2/section3/part1/detail3.html","title":"3. 定义拓展类入口","keywords":"","body":"定义拓展类入口1. Extensions类说明2. EntryPoint类的实现定义拓展类入口 本小节将对Extensions类进行说明，并引导用户定义一个 EntryPoint类。 EntryPoint类是扩展库的入口，继承自iS3.Core中的Extensions类。通过EntryPoint类，主程序运行时才能识别用户自定义的数字化对象实体类。 1. Extensions类说明 iS3.Core中的Extensions类是用户实现自定义扩展类所依赖的重要对象。所有用户自定义的扩展类均需继承自该Extensions类，否则无法实现扩展。Extensions类的定义如下所示： public class Extensions { // Summary: // Name, version and provide of the extension public virtual string name() { return \"Unknown extension\"; } public virtual string version() { return \"Unknown\"; } public virtual string provider() { return \"Unknown provider\"; } // Summary: // Initialize the extension, called immediately after loaded. // Return value: // A string that will be printed in output window. public virtual string init() { string msg = String.Format(\"Loaded {0} by {1}, version {2}.\\n\", name(), provider(), version()); return msg; } } 自定义的扩展类继承自Extensions类后，编译生成的动态链接文件应该放置在\\bin\\extensions目录下，否则无法被主程序识别。iS3.Core中的ExtensionsManager类将读取放置于\\bin\\extensions目录下的dll文件，从类名中创建出实体。 2. EntryPoint类的实现 此处，我们将演示如何实现扩展类的入口——EntryPoint类，并对其函数进行简要介绍。 以同济大学项目的演示为例，代码如下： namespace iS3.Geology { // Summary: // This is the entry point for the extension public class EntryPoint : Extensions { public override string name() { return \"iS3.Geology\"; } public override string provider() { return \"Tongji iS3 team\"; } public override string version() { return \"1.0\"; } } } 此处，我们首先需要继承Extensions类，以声明自定义类的扩展属性。其次，我们还需重载Extensions类的三个函数，尤其是 name() 函数，这是识别出自定义类所处的命名空间的关键。 重载函数说明 name()：返回所处的命名空间。此处所处的namespace为iS3.Geology，所以应该返回\"iS3.Geology\"。 provider() ：返回开发团队名称。 version()：返回版本信息。 © Tongji University all right reserved，File Modify: 2020-01-28 11:55:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part1/detail4.html":{"url":"chapter2/section3/part1/detail4.html","title":"4.修改运行配置","keywords":"","body":"运行配置1. 生成解决方案2. 修改dll文件路径3. 启动项目运行配置 1. 生成解决方案 此处应点击上方绿色箭头，生成相应项目的解决方案。 生成情况如下图所示： 2. 修改dll文件路径 如第二小节（定义扩展类入口）所述，扩展类生成的dll文件必须放置在\\bin\\extensions目录下，才能被ExtensionManager类读取。但默认情况下生成的dll文件路径如上图所示(Debug模式)。因此，我们必须将生成的扩展类的dll文件和pdb文件移动到iS3-Desktop-Client\\bin\\extensions目录下。 也可以选择在生成解决方案之前，在csproj中对路径进行修改，此处不再附图。 注意：在Visual Studio 2017的环境下可能会出现无法启动程序的弹窗，但控制台会显示是否生成成功。 3. 启动项目 启动iS3-Desktop.csproj，你将看到运行成功的IS3桌面应用程序。 © Tongji University all right reserved，File Modify: 2020-01-29 11:40:30 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part2.html":{"url":"chapter2/section3/part2.html","title":"第二节 C#接口文档","keywords":"","body":"C#接口文档C#接口文档 iS3平台遵循MVC模式进行开发，并允许用户调用已存在的类和方法进行二次开发。此处我们分常用接口和数据调用接口对可供调用的C#方法进行说明。常用接口部分介绍二次开发中经常调用的MVC类和方法；数据调用接口介绍iS3中已存在的数据化对象类，包括Monitoring、Borehole等类。 常用接口 数据调用接口 设计模式图 设计模式示意图如下所示： © Tongji University all right reserved，File Modify: 2020-01-30 01:03:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part2/常用接口.html":{"url":"chapter2/section3/part2/常用接口.html","title":"常用接口","keywords":"","body":"常用接口常用接口 此处介绍二次开发中经常调用的MVC类和方法，这些类位于iS3.Core命名空间下。 © Tongji University all right reserved，File Modify: 2020-01-29 13:19:59 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part2/数据调用接口.html":{"url":"chapter2/section3/part2/数据调用接口.html","title":"数据调用接口","keywords":"","body":"数据调用接口数据调用接口 此处提供iS3数据结构的调用接口，包括Monitoring、Borehole等数字化对象实体类，供用户二次开发调用。 © Tongji University all right reserved，File Modify: 2020-01-29 13:31:52 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part3.html":{"url":"chapter2/section3/part3.html","title":"第三节 拓展工具面板","keywords":"","body":"拓展工具面板拓展工具面板 iS3平台允许用户自定义工具面板下的工具，从而满足用户的个性化工具使用需求。此处，我们将提供一个DemoTool工具样例，并对其开发过程和最终效果进行简要说明。 简要说明 开发过程 © Tongji University all right reserved，File Modify: 2020-01-30 00:21:32 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part3/简要说明.html":{"url":"chapter2/section3/part3/简要说明.html","title":"简要说明","keywords":"","body":"DemoTool简要说明DemoTool简要说明 DemoTool是一个简单的小工具，可以展示所有MonPoint监测点以及相应的监测曲线（尚未定义）。此处将对DemoTool的使用进行简要说明。 首先进入到某个iS3工程项目，点击右下角的Tools面板，可以看到Tools下有Toolboxes->Demo->Basic->DemoTest的层级关系，其中DemoTest即为本DemoTool的标识。 点击该“DemoTest”字样，弹出“Demo MonPoint View”视图窗口，该视图左侧展示该工程项目中所有的MonPoint监测点的名称。 点击左侧列表中任意监测点（此处点击Mon-1），右侧即显示相应监测点的监测曲线（尚未定义），并在地图上将对应监测点的图标高亮。如下图所示： © Tongji University all right reserved，File Modify: 2020-01-30 00:37:15 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section3/part3/开发过程.html":{"url":"chapter2/section3/part3/开发过程.html","title":"开发过程","keywords":"","body":"开发过程开发过程 此处，我们将对DemoTool的开发过程进行简要介绍，通过该流程你将掌握在iS3平台中拓展工具面板的方法。 1. 新建项目 实现工具面板的拓展首先需要在IS3-Tools.sln下新建项目，用以存储DemoTool有关文件。 打开IS3-Tools.sln，右键 解决方案 'IS3-Tools.sln'->添加(D)->新建项目(N) 选择 类库(.NET Framework)，名称填写拓展工具的名称（此处为DemoTools），路径为IS3-Tools下(默认)，点击确认生成新项目。 2. 定义工具实体类 iS3 系统在 iS3.Core 中定义了 Tools 类，该类继承自 Extensions 类，用于实现用户自定义工具的扩展。用户自定义的工具均需继承自该类，否则不能被IS3程序识别。Tools 类的定义如下所示： public class Tools : Extensions { // Summary: // Name, version and provide of the tool public override string name() { return \"Unknown tool\"; } // Summary: // Get treeItems of the tool, called immediately after loaded. public virtual IEnumerable treeItems() { return null; } } 我们定义一个DemoTool类，该类继承自 Tools 类，实现的功能可参见简要说明。定义过程中我们需要对name等基本信息进行重载，并对工具列表、工具窗口以及工具树进行初始化。工具窗口DemoWindow类则在DemoWindow.xaml.cs中被定义。 DemoTool 类的定义和注释如下所示： public class DemoTools : Tools { //基本信息 public override string name() { return \"iS3.DemoTools\"; }//命名空间 public override string provider() { return \"Tongji iS3 team\"; }//开发团队 public override string version() { return \"1.0\"; }//版本 //初始化工具列表 List items; public override IEnumerable treeItems(){ return items; } //初始化工具窗口 DemoWindow demoWindow; //定义调用弹窗的函数 public void callDemoWindow(){ //视图非空，展示窗口 if (demoWindow != null){ demoWindow.Show(); return; } //视图为空，定义弹窗并展示 demoWindow = new DemoWindow(); demoWindow.Closed += (o, args) =>{ demoWindow = null; }; demoWindow.Show(); } //初始化DemoTools public DemoTools(){ //新建工具树 items = new List(); //定义工具树层级及名称，以及触发的函数（弹出工具窗口） ToolTreeItem item = new ToolTreeItem(\"Demo|Basic\", \"DemoTest\", callDemoWindow); items.Add(item); } } 注意：可通过右键 引用 ->添加引用 ->浏览 添加引用文件，如下图所示。在该DemoTool的实现中，我们需要调用IS3-Core等项目中的文件，需要添加iS3.Core.dll，iS3.Monitoring.dll等文件。 3. 定义有关视图 定义了DemoTool类之后，我们需要定义其对应的视图弹窗，即主要的功能部分。在DemoWindow.xaml.cs中定义DemoTool有关的视图和触发事件，详细可查看。由于代码较长，此处不复展开详述。此处，放出最终效果： //DemoWindow:交互部分 public partial class DemoWindow : Window { //对象选取监听 public EventHandler objSelectionChangedTrigger; //初始化DemoWindow public DemoWindow() { InitializeComponent(); Loaded += DemoWindow_Loaded; } private void DemoWindow_Loaded(object sender, RoutedEventArgs e) { //监听点击工具面板事件 objSelectionChangedTrigger += Globals.mainframe.objSelectionChangedListener; Globals.mainframe.objSelectionChangedTrigger += objSelectionChangedListener; //获取项目中的所有MonPoint名称并加载到面板左侧 Project prj = Globals.project; Domain monDomain = prj[\"Monitoring\"]; DGObjectsCollection dc = monDomain.getObjects(\"MonPoint\"); listLB.ItemsSource = dc.FirstOrDefault().values; } //监听点击某一MonPoint事件 private void objSelectionChangedListener(object sender,ObjSelectionChangedEventArgs e) { //加载监测曲线 if (view == null) { view = Globals.mainframe.getViewByID(\"DemoLineChart\"); holder.Children.Add(view as UserControl); } MonPoint mp = e.addedObjs.Values.FirstOrDefault().FirstOrDefault() as MonPoint; view.SetData(string.Format(\"测点{0}监测曲线\", mp.Name), mp.readingsDict.Values.FirstOrDefault().ToList(), \"time\", \"value\", \"\", mp.Name); } DGObject _lastObj; IBaseView view; //改变左侧MonPoint列表 private void listLB_SelectionChanged(object sender, SelectionChangedEventArgs e) { DGObject selectOne = listLB.SelectedItem as DGObject; List addedObjs = new List(); List removedObjs = new List(); //标注选中MonPoint项 if ((_lastObj != null) && (_lastObj.Name == selectOne.Name)) return; addedObjs.Add(selectOne); if (_lastObj != null) { removedObjs.Add(_lastObj); } if (objSelectionChangedTrigger != null) { Dictionary> addedObjsDict = null; Dictionary> removedObjsDict = null; if (addedObjs.Count > 0) { addedObjsDict = new Dictionary>(); addedObjsDict[selectOne.parent.definition.Name] = addedObjs; } if (removedObjs.Count > 0) { removedObjsDict = new Dictionary>(); removedObjsDict[_lastObj.parent.definition.Name] = removedObjs; } ObjSelectionChangedEventArgs args = new ObjSelectionChangedEventArgs(); args.addedObjs = addedObjsDict; args.removedObjs = removedObjsDict; objSelectionChangedTrigger(this, args); } _lastObj = selectOne; } } 4. 生成解决方案 完成有关文件的定义后，需要重新生成解决方案，并将生成的dll文件放置于iS3-Desktop-Client\\Output\\tools 目录下，否则不被识别。 5. 最终效果 最终效果如下图所示： © Tongji University all right reserved，File Modify: 2020-01-30 02:31:19 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4.html":{"url":"chapter2/section4.html","title":"第四章 Python接口","keywords":"","body":"Python接口Python接口 本节将对iS3的Python开发和使用进行相关介绍和说明。本节共分为4个小节，这4个小节分别介绍了iS3系统中Python开发所涉及的脚本库，调用方式以及开发样例，并附上is3.py脚本库的使用说明，供用户调用。此外，本章还对Python二次开发过程中常见的部分问题进行解答。 Python相关库 Python调用方式 Python接口使用demo iS3脚本库使用说明 1. Attribute 2. Class 3. Function 常见问题 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/Python相关库.html":{"url":"chapter2/section4/Python相关库.html","title":"第一节 Python相关库","keywords":"","body":"Python相关库1. IS3-Python2. Python扩展插件3. Python脚本库4. Python配置文件5. 原readme.txt附件Python相关库 在这里我们将介绍一下iS3中与Python开发相关的文件库和脚本。本小节将围绕IS3-Python脚本库，Python扩展插件库，Python脚本库，Python配置文件等四个部分内容进行介绍。小节末尾，附上了Python进行iS3开发的readme.txt原件，供读者查阅。 1. IS3-Python 放置于..\\iS3-Desktop-Client\\IS3-Python文件目录下的C#代码库，提供IS3内置的Python功能，包括对IronPythonControl等的实现和控制，一般不必关心。 2. Python扩展插件 放置于..\\iS3-Desktop-Client\\Output\\PyPlugins文件目录下的*.py脚本文件库。主程序运行时将自动执行位于该路径下的所有Python脚本文件（通过Mainframe.xaml.cs文件中定义的loadPyPlugins函数进行加载）。 iS3中提供了名为plugin-demo.py的测试文件，该样例位于..\\Output\\IS3Py目录下。 注：初始情况下该路径不存在，需用户手动创建该文件夹。 3. Python脚本库 放置于..\\Output\\IS3Py\\目录下的Python脚本文件。该目录下的脚本文件供用户在使用Python进行二次开发时调用。用户编写的Python文件也应放置于该目录下，使用时以import语句导入该库名称即可。 以iS3.py脚本库为例，该库提供了对addView()的封装等操作,调用样例可参考TONGJI.py和plugin-demo.py。 补充说明：IronPython-2.7.5.msi是iS3 二次开发主要插件，软件开发和发布都需要安装此插件。二次开发内嵌Python语言开发工具，提供Python语言开发范例，提供C#二次开发接口和范例。 4. Python配置文件 放置于..\\iS3-Desktop-Client\\Output\\Data\\[project_name]文件目录下的Python脚本文件。该Python脚本可作为iS3工程管理的入口，主要用于初始化工程，关联XML配置文件，导入二维、三维图形以及数据。该文件实际上就是用于加载[project_name]工程的Python脚本，是加载iS3工程项目的另一种方式（还有一种就是在iS3-Desktop里通过C#加载 ）。 以TONGJI的工程项目为例，Python配置文件格式如下所示。其中，LoadPrj() 函数用于加载工程及其相应XML文件。该py文件在使用config.exe配置项目时自动配置生成。 # -*- coding:gb2312 -*- import is3 is3.mainframe.LoadProject('TONGJI.xml') is3.prj = is3.mainframe.prj is3.MainframeWrapper.loadDomainPanels() for emap in is3.prj.projDef.EngineeringMaps: is3.MainframeWrapper.addView(emap) is3.addView3d('Map3D', 'TONGJI.unity3d') 5. 原readme.txt附件 此处附上原readme文件（略有修正）。 readme.txt (1) Scripts can be loadded and runned in iS3. In this case, the scripts is runned in the main UI thread. Note that script call to IS3View.addGdbLayer will hang the program (load tt. py will hang the program). This problem doesn't exist in the following case. (2) Scripts can be inputted and runned immediately in the Python console window. In this case, the scripts is runned in another thread which is different from the main UI thread. In Windows, UI thread vars and functions are restricted to other threads. So, be caution with script calls to functions in UI thread. Classes in the main UI thread include: mainframe, view, layer, etc. (3) is3. py provides some friendly classes and vars to facilitate use of iS3, such as adding views and layers. Please note that wrapper classes to mainframe, view, and layer are provided to overcome the restrictions of calls to the main UI thread. The wrapper classes are also called thread safe classes. (4) Scripts located in /IS3/bin/PyPlugins/(修正：实际应为../Output/PyPlugins) will be automatically runned when program starts. It is a nice place to put your frequent use scripts here, such as user-defined toolboxes. See plugin-demo. py for more details. © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/Python调用方式.html":{"url":"chapter2/section4/Python调用方式.html","title":"第二节 Python调用方式","keywords":"","body":"Python调用方式1. IronPython Console2. IronPython Pad3. Python扩展插件Python调用方式 此处将介绍调用Python脚本文件的3种途径，包括IronPython控制面板，IronPython Pad面板，以及Python扩展插件库，并对其适用场景和使用方法进行简单介绍。 1. IronPython Console IronPython控制面板如下图所示，此处可实时执行Python代码，适用于实时的、简短直接的调用或测试。注意。供调用的Python脚本库应放置在..\\Out\\IS3Py\\目录下。 理论上位于.. \\Output\\PyPlugins路径下的Python脚本库也会被iS3识别，但由于位于该目录下的脚本文件在主程序运行时就会被自动执行，不适用于上述场景。 此处，我们将对Console的使用进行简单示范。 测试用例： >>> import is3 >>> is3.addView3d('Map3D', 'TONGJI.unity3d') ﻿ 测试结果： 工程图形展示面板多了一层名为Map 3D的3D图层。 2. IronPython Pad IronPython Pad面板如下所示，此处可加载并执行Python脚本文件，可点击文件图标打开指定路径下的文件加载脚本，也可以直接在该面板编写长段代码。执行代码请点击绿色箭头图标。 3. Python扩展插件 如第一小节所述，位于.. \\Output\\PyPlugins目录下的所有python文件都会在加载工程时被自动执行。 以plugin-demo.py为例，将plugin-demo.py脚本文件放置于该目录下，加载工程时自动执行该脚本，将Demo加至Tools面板。点击该Demo字样时，系统会在图形展示面板添加一层名为Demo的3D图层， © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/Python接口使用demo.html":{"url":"chapter2/section4/Python接口使用demo.html","title":"第三节 Python接口使用demo","keywords":"","body":"Python接口使用demo1. API格式2. 传入参数3. 开发过程3.1 编写C#调用接口3.2 重新生成dll3.3 编写Python接口4. 测试用例5. 测试结果Python接口使用demo 此处将示例如何利用C#和Python两种语言协同进行接口开发，示例功能为选出属性值在某一范围内的数字化对象（DGObject），并将其图标和数据行高亮。该demo目前仅支持Borehole类型下对top属性的筛选。由于需要传入参数，该demo适合在IronPython Console中调用。 1. API格式 API调用格式如下： toolDemo.test(type,attribute,down,up) 2. 传入参数 type：Domain类型，目前只支持Borehole attribute: 筛选的属性，目前只支持Borehole的top属性 down：下限 up: 上限 3. 开发过程 3.1 编写C#调用接口 此处我们将在C#程序里添加两个功能，getDGObject()和selectObject()函数以供Python调用。娴熟Python者也可以尝试纯Python开发出自己的工具。 getDGObjec()函数添加在DGOjects.cs文件中，该函数作用是以数组形式返回DGOjects里所包含的所有DGOject。代码如下： //in DGOjects.cs public DGObject[] getDGObject(){ int size=_objs.Count; DGObject[] objs = new DGObject[size]; _objs.Values.CopyTo(objs, 0); return objs; } selectObject() 函数添加在IS3View.cs文件中，该函数用于选取并高亮指定的数字化对象DGObject。代码如下： //in IS3View.cs public void selectObject(String type,DGObject obj){ if (Globals.isThreadUnsafe()) { Globals.application.Dispatcher.Invoke(new Action(()=> { selectObject(type,obj); })); return; } if(type==\"Borehole\"){ IS3GraphicsLayer glayer=getLayer(type) as IS3GraphicsLayer; glayer.highlightObject(obj,true); } ObjSelectionChangedEventArgs args=new ObjSelectionChangedEventArgs(); args.addedObjs=new Dictionary>(); List objs=new List(); objs.Add(obj); args.addedObjs.Add(objs.FirstOrDefault().parent.definition.Name, objs); objSelectionChangedTrigger(this,args); } 3.2 重新生成dll 在C#里添加了自己的代码后，需要重新生成解决方案，更新动态链接库。 3.3 编写Python接口 在此，我们将调用上述补充的C#接口，完成自定义demo。代码如下： import is3 from is3 import DomainType,Globals # Changes # IS3View.cs: public void selectObject(String type,DGObject obj) # DGOjects.cs: public DGObject[] getDGObject() # Relative Classes # IS3View.cs, DGOjects.cs, Domain.cs, MainFrame.xaml.cs # Relative Functions # public async Task selectByPoint(Point screenPoint) IS3View.cs # public void objSelectionChangedListener(object sender,ObjSelectionChangedEventArgs e) MainFrame.xaml.cs def test(type,attribute,down,up): if(down>up): # tranform into lower case tmp=up up=down down=tmp attr=attribute.lower() tp=type.lower() if(tp==\"borehole\"): # 'Borehole' type domain=is3.prj.getDomain(DomainType.Geology) objs=domain[\"Allboreholes\"] obj=objs.getDGObject() # list of DGObject if(attr==\"top\"): # 'top' attribute for i in obj: if((i.Top=down)): is3.mainframe.views[0].selectObject(\"Borehole\",i) else: print(\"No such attribute\") 4. 查看效果 完成后将在IronPython Console里对该demo的实现效果进行测试。 4. 测试用例 在IronPython Console面板里输入以下代码： >>> import toolDemo >>> toolDemo.test('borehole','top',2.7,2.75) 5. 测试结果 测试效果如下图： 由上图可见，符合范围内的Borehole类型的数字化对象在地图和Data View上均被高亮，且在Object View面板中被展示。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/iS3脚本库说明.html":{"url":"chapter2/section4/iS3脚本库说明.html","title":"第四节 iS3脚本库使用说明","keywords":"","body":"iS3脚本库说明iS3脚本库说明 该项目中..\\Output\\IS3Py目录下放置了以i3.py为主、供用户调用的Python脚本库。plugin-demo.py, graphics-demo.py都是调用is3库封装的函数以实现功能的范例。用户编写的python脚本文件也可放置在该目录下，供IronPythonConsole面板调用。 本文档将介绍is3.py脚本库中的所有函数，供用户对照使用。 1. Attributes 2. Class 3. Function © Tongji University all right reserved，File Modify: 2020-01-29 12:13:19 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/Attributes.html":{"url":"chapter2/section4/Attributes.html","title":"1. Attribute","keywords":"","body":"1. Attribute1.1 属性名称1.2 属性定义1.3 属性说明1.3.1 mainframe1.3.2 prj1.3.3 dispatcher1.3.4 graphicsEngine1.3.4 geometryEngine1. Attribute is3脚本库中直接封装了程序运行时的一些全局变量，为用户提供了更为灵活的开发空间。由于UI 线程变量以及函数被限制在其他线程当中，因此，在UI线程中使用Python调用函数时应分外小心。直接调用is3脚本库编写函数时需注意使用delegate方法。 1.1 属性名称 序号 属性名称 属性类型 简要说明 1 mainframe IMainFrame UI的主要框架 2 prj Project 项目工程 3 dispatcher Dispatcher mainframe的分发器 4 graphicsEngine IGraphicEngine graphics engine 5 geometryEngine IGeometryEngine 几何引擎 1.2 属性定义 源代码定义如下： mainframe = Globals.mainframe # Global var: mainframe prj = mainframe.prj # Global var: prj dispatcher = mainframe.Dispatcher # Global var: dispatcher -> UI thread manager graphicsEngine = Runtime.graphicEngine # Global var: graphics Engine geometryEngine = Runtime.geometryEngine # Global var: geometry Engine 1.3 属性说明 1.3.1 mainframe 属性 mainframe 对应主程序的全局变量mainframe，相当于 MVC 架构中Controller，用于控制应用程序的流程，处理事件并做出响应。 1.3.2 prj 属性 prj 对应主程序的全局变量prj， 对应当前打开的工程项目，相当于MVC架构中的Model，用于封装与工程项目（Project）业务逻辑相关的数据和处理数据的方法。 1.3.3 dispatcher 属性 dispatcher 是主程序mainframe框架下的分发器，用于任务的分发。 1.3.4 graphicsEngine 属性 graphicsEngine 对应主程序 Runtime 机制下的图形引擎，用于图形界面的处理。 1.3.4 geometryEngine 属性 geometryEngine对应主程序 Runtime 机制下的几何引擎，用于几何图形界面的处理。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/Class.html":{"url":"chapter2/section4/Class.html","title":"2. Class","keywords":"","body":"2. Class2.1 MainframeWrapper2.1.1 addView2.1.2 loadDomainPanels2. Class 为了实现UI线程中函数的安全调用，is3脚本库中定义了了一些类，将Mainframe，View中的函数以Wrapper的形式进行包装。 2.1 MainframeWrapper MainframeWrapper类下目前有两个方法，且均为静态方法，可直接调用。 2.1.1 addView 接口功能 静态方法，添加新的视图（View）。封装在MainrameWrapper类中，调用了Mainframe.xaml.cs中的addView()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 emap EngineeringMap 是 无 需添加的工程地图 2 canClose bool 否 无 默认为true 返回结果 类型 示例值 描述 ViewWrapper 无 返回新View的包装类 调用示例 emap = is3.EngineeringMap('demo', 0, 0, 100, 100, 0.01) safe_view = is3.MainframeWrapper.addView(emap) 2.1.2 loadDomainPanels 接口功能 静态方法，加载Domain面板，应用于加载工程项目时。封装在MainrameWrapper类中，调用Mainframe.xaml.cs中的loadDomainPanels()函数。 接口参数 无 返回结果 void 调用示例 import is3 is3.MainframeWrapper.loadDomainPanels() 2.2 ViewWrapper ViewWrapper中的addGdbLayer()和addShpLayer()方法一般不直接调用，添加GdbLayer和ShpLayer时应调用is3下封装好的addGdbLayer()和addShpLayer()方法。 2.2.1 _init_ 接口功能 初始化ViewWrapper 接口参数 序号 名称 类型 是否必须 示例值 描述 1 view IView 是 无 graphics 图层 返回结果 类型 示例值 说明 ViewWrapper 无 返回IView的包装类 调用示例 无 2.2.2 addLayer 接口功能 添加新的图层（Layer）。封装在ViewWrapper类中，调用了View.cs中的addLayer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 layer IGraphicsLayer 是 无 graphics 图层 返回结果 void 调用示例 import is3 emap = is3.EngineeringMap('demo', 0, 0, 100, 100, 0.01) safe_view = is3.MainframeWrapper.addView(emap) layer3WP = is3.newGraphicsLayer('layer3', 'layer3') safe_view.addLayer(layer3WP.layer) 2.2.3 addLocalTiledLayer 接口功能 添加本地的Tiled Layer文件，文件格式为.TPK。该函数封装在ViewWrapper类中，调用了View.cs中的addLocalTiledLayer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 file string 是 “Empty.tpk” .TPK文件的绝对路径 2 id string 是 'baselayer' layer的唯一标识 返回结果 void 调用示例 import is3 # tilePath: path to tiled packages (.TPK) tilefile = is3.Runtime.tilePath + \"\\\\Empty.tpk\" safe_view.addLocalTiledLayer(tilefile, 'baselayer') 2.2.4 addGdbLayer 接口功能 从本地的geodatabase中动态加载Gdb图层(GdbLayer)。该函数封装在ViewWrapper类中，调用了View.cs中的addGdbLayer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 layerDef LayerDef 是 无 layer definition 2 gdbFile string 是 无 geodatabase文件名 3 start int 否 无 layer中feature的起始索引，默认为 0 4 maxFeatures int 否 无 加载layer时所允许的最大features，默认为 0 返回结果 类型 示例值 描述 GraphicsLayerWrapper 无 返回新GraphicsLayer的包装类 调用示例 import is3 layerWrapper = viewWrapper.addGdbLayer(layerDef, gdbFile, start, maxFeatures) 2.2.5 addShpLayer 接口功能 从本地的shape文件中动态加载Shp图层(ShpLayer)。该函数封装在ViewWrapper类中，调用了View.cs中的 addShpLayer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 layerDef LayerDef 是 无 layer definition 2 shpFile string 是 无 shape file文件名 3 start int 否 无 layer中feature的起始索引，默认为 0 4 maxFeatures int 否 无 加载layer时所允许的最大features，默认为 0 返回结果 类型 示例值 描述 GraphicsLayerWrapper 无 返回新GraphicsLayer的包装类 调用示例 import is3 layerWrapper = viewWrapper.addShpLayer(layerDef, shpfile, start, maxFeatures) 2.2.6 selectByRect 接口功能 在iS3程序中，对应图层左上方的紫色矩形select objects on the map的触发。该函数封装在ViewWrapper类中，调用了IS3View.cs中的 selectByRect()函数。 该函数调用尚不明确，功能尚不完善。 2.3 GraphicsLayerWrapper 2.3.1 _init_ 接口功能 初始化GraphicsLayerWrapper。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 glayer IS3GraphicsLayer 是 无 需包装的Graphic图层 返回结果 类型 示例值 说明 GraphicsLayerWrapper 无 返回IS3GraphicsLayer的包装类 调用示例 import is3 layer = graphicsEngine.newGraphicsLayer(id, displayName) layerWrapper = GraphicsLayerWrapper(layer) 2.3.2 setRenderer 接口功能 设置Render。该函数封装在GraphicsLayerWrapper类中，调用了IS3Layer.cs中的 setRenderer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 renderer IRenderer 是 无 需设置的Renderer目标 返回结果 void 调用示例 import is3 renderer1 = is3.graphicsEngine.newSimpleRenderer(sym_point) layer1WP = is3.newGraphicsLayer('layer1', 'layer1') layer1WP.setRenderer(renderer1) 2.2.3 addGraphic 接口功能 添加Graphic图层。该函数封装在GraphicsLayerWrapper类中，调用了IS3Layer.cs中的 addGraphic()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 graphic IGraphic 是 无 需添加的Graphic图层 返回结果 void 调用示例 import is3 line = is3.graphicsEngine.newLine(x1, y1, x2, y2, sr) myLayer.addGraphic(line) © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/Function.html":{"url":"chapter2/section4/Function.html","title":"3. Function","keywords":"","body":"3. Function3.1 newGraphicsLayer3.2 addView3d3.3 addGdbLayer3.4 addGdbLayerLazy3.5 addShpLayer3. Function 这里将is3脚本库定义的类的函数进行进一步封装，可满足用户添加图层的基本需求。如果用户想要更多的功能性拓展，仿照addView()等函数的写法，调用C#中的函数即可。 3.1 newGraphicsLayer 接口功能 新建graphics layer层。该函数调用了IS3GraphicEngine.cs中的 newGraphicsLayer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 id string 是 无 无 2 displayName string 是 无 无 返回结果 类型 示例值 说明 GraphicsLayerWrapper 无 返回新IS3GraphicsLayer的包装类 调用示例 import is3 layer1WP = is3.newGraphicsLayer('layer1', 'layer1') 3.2 addView3d 接口功能 添加3D视图。调用了MainframeWrapper中的 addView()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 id string 是 无 Map 的唯一标识符 2 file string 是 无 本地3D文件路径 返回结果 类型 示例值 描述 ViewWrapper 无 返回新3D视图的包装类 调用示例 import is3 is3.addView3d('Map3D', 'TONGJI.unity3d') 3.3 addGdbLayer 接口功能 动态加载Gdb图层(GdbLayer)，调用了ViewWrapper中的addGdbLayer()函数。添加GdbLayer调用该函数而非ViewWrapper中的addGdbLayer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 viewWrapper ViewWrapper 是 无 需加载的目标视图 2 layerDef LayerDef 是 无 layer definition 3 gdbFile string 否 无 gdb文件路径，默认None 4 start int 否 无 默认0 5 maxFeatures int 否 无 默认0 返回结果 类型 示例值 描述 GraphicsLayerWrapper 无 返回新图层的包装类 调用示例 import is3 strLayerWP = is3.addGdbLayer(viewWP, layerDef) 3.4 addGdbLayerLazy 接口功能 新建指定类型的空白Gdb图层(GdbLayer)。调用了addGdbLayer()函数。与2.6区别：加载和新建。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 view ViewWrapper 是 无 需加载的目标视图 2 name string 是 无 图层名称 3 type string 是 无 图层类型 4 gdbFile string 否 无 Gdb文件路径，默认None 5 start int 否 无 默认0 6 maxFeatures int 否 无 默认0 返回结果 类型 示例值 描述 GraphicsLayerWrapper 无 返回新图层的包装类 调用示例 import is3 is3.addGdbLayerLazy(viewWP, 'MON_WAT', is3.GeometryType.Point) 3.5 addShpLayer 接口功能 从本地的shape文件中动态加载Shp图层(ShpLayer)。调用了ViewWrapper中的 addShpLayer()函数。添加ShpLayer时调用该函数而非ViewWrapper中的addShpLayer()函数。 接口参数 序号 名称 类型 是否必须 示例值 描述 1 viewWrapper ViewWrapper 是 无 无 2 layerDef LayerDef 是 无 无 3 shpfile string 是 无 无 4 start int 否 无 默认0 5 maxFeatures int 否 无 默认0 返回结果 类型 示例值 描述 GraphicsLayerWrapper 无 返回新图层的包装类 调用示例 import is3 bkgLayerWP = is3.addShpLayer(viewWP, layerDef, file, start, maxFeatures) © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter2/section4/常见问题.html":{"url":"chapter2/section4/常见问题.html","title":"第五节 常见问题","keywords":"","body":"常见问题1. 调用线程无法访问2. Mainframe访问异常3. toolPanel不支持更改4. C#新增函数异常常见问题 此处介绍了部分Python进行二次开发过程中可能遇到的问题，并提供解决途径。 1. 调用线程无法访问 情景描述 报错如下： >>> is3.mainframe.views[0] >>> view=is3.mainframe.views[0] >>> view.selectObject(obj[0]) Traceback (most recent call last): File \"\", line 1, in SystemError: 调用线程无法访问此对象，因为另一个线程拥有该对象。 报错原因 出现上述异常时因为多个线程同时访问一个对象造成的。C# 2005之后不再支持多线程直接访问界面的控件(界面创建线程与访问线程不是同一个线程)，但是可以使用delegate来解决。 解决途径 Python或C#里调用 Dispatcher.Invoke 方法，保证调用线程是在其上创建 DispatcherObject 的线程。 可参考 is3.py 的MainframeWrapper 类中写法： @staticmethod def loadDomainPanels(): \"A thread safe call to -> mainframe.loadDomainPanels()\" if (Globals.isThreadUnsafe()): dispatcher.Invoke(mainframe.loadDomainPanels) else: mainframe.loadDomainPanels() 2. Mainframe访问异常 情景描述 通过Mainframe访问C#函数时，出现\"has no attribute\"的异常。报错如下： >>> is3.MainframeWrapper.selctObject(obj[0]) Traceback (most recent call last): File \"\", line 1, in AttributeError: 'classobj' object has no attribute 'selctObject' 报错原因 可能是Mainframe还没有被赋值。 解决途径 可以尝试重新定位一下mainframe。 3. toolPanel不支持更改 情景描述 在 IronPython Pad 执行 plugin-demo.py 时报错。 Traceback (most recent call last): File \"\", line 52, in SystemError: 该类型的 CollectionView 不支持从调度程序线程以外的线程对其 SourceCollection 进行的更改。 报错原因 不支持在主程序加载完毕后对 toolPanel 再进行更改。 解决途径 将需要更改 toolPanel 的Python脚本放在 .. \\Output\\PyPlugins 目录下，让其在项目启动时自动执行即可。 4. C#新增函数异常 情景描述 用户自定义添加的C#接口，Python调用时无法识别，Console面板报错has no attribute。 报错原因 没有更新dll。 解决途径 解决：重新生成 IS3-Core.csproj（例如）的解决方案。在1.0 版本中，需要把..\\iS3-Standalone-V1.0\\Output\\bin目录下的新生成的 IS3. Core.dll 和 IS3.Core.pdb 拷贝到 ..\\S3-Standalone-V1.0\\iS3-Standalone-V1.0\\Output\\bin中，替换原有dll和pdb。 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/":{"url":"chapter3/","title":"三、附录","keywords":"","body":"附录附录 Entity Framework Code First与数据表之间有两种映射方式，选择某一种方式或两种方式兼用也可，根据不同方式创建表名。 EFCF属性映射约定 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/appendix.html":{"url":"chapter3/appendix.html","title":"第一章 EFCF属性映射约定","keywords":"","body":"Entity Framework Code First属性映射约定Entity Framework Code First属性映射约定 Entity Framework Code First与数据表之间的映射方式有两种实现：Data Annotation和Fluent API。这里采用创建产品类（Product）为例来说明Entity Framework Code First属性映射约定的具体方式。 表名及所有者 字段名、长度、数据类型及是否可空 主键 数据库自动生成字段值 数字类型长度及精度 非数据库字段属性 Fluent API配置Configuration映射类 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/section1/appendix1.html":{"url":"chapter3/section1/appendix1.html","title":"第一节 表名及所有者","keywords":"","body":"表名及所有者Data Annotation 方式Fluent API方式表名及所有者 在不指定表名的情况下，Entity Framework Code First创建的表名采取默认操作，即根据类名的英语复数形式创建表名。创建的表所有者为dbo，可以通过替换约定来指定表名及表的所有者。 Data Annotation 方式 在使用Data Annotation方式进行Entity Framework Code First与数据库映射之前，需要先添加命名空间引用。 using System.ComponentModel.DataAnnotations.Schema; 为类配置对应表名，在不指定表名的情况下，创建的表名采取默认操作，即根据类名的英语复数形式创建表名： [Table(\"Product\")] public class Product 为类配置对应表名并指定表的所有者： [Table(\"Product\", Schema = \"dbo\")] public class Product Fluent API方式 Fluent API实现配置Entity Framework Code First与数据库映射关系主要是通过继承DbContext并重写其中的OnModelCreating方法来进行的。在本文中新建类文件PortalContext.cs继承DbContext。 在继承DbContext之前，添加命名空间引用。 using System.Data.Entity; 重写OnModelCreating方法，配置类对应于数据库中的表名： protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().ToTable(\"Product\"); } 重写OnModelCreating方法，配置类对应于数据库中的表名，并指定表的所有者： protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().ToTable(\"Product\", \"dbo\"); } 到此处PortalContext.cs的完整代码： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Data.Entity; using Portal.Entities; namespace Portal { public class PortalContext : DbContext { static PortalContext() { Database.SetInitializer(new DropCreateDatabaseIfModelChanges()); } public PortalContext() : base(\"name=PortalContext\") { } public DbSet Products { get; set; } protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().ToTable(\"Product\", \"dbo\"); } } } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/section1/appendix2.html":{"url":"chapter3/section1/appendix2.html","title":"第二节 字段名、长度、数据类型及是否可空","keywords":"","body":"长度、数据类型及是否可空Data Annotation 方式Fluent API方式长度、数据类型及是否可空 在默认约定的情况下，Entity Framework Code First创建的列名与类的属性名相同，可以根据需要进行重新指定类属性与列名之间的映射关系。 Data Annotation 方式 [Column(\"ProductID\")] public int ProductID { get; set; } [MaxLength(100)] [Required, Column(\"ProductName\")] public string ProductName { get; set; } 在使用Required特性(Attribute)设置字段不允许为空时，需要添加命名空间引用： using System.ComponentModel.DataAnnotations; Fluent API方式 protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().Property(t => t.ProductID) .HasColumnName(\"ProductID\"); modelBuilder.Entity().Property(t => t.ProductName) .IsRequired() .HasColumnName(\"ProductName\") .HasMaxLength(100); } 在默认情况下，int类型的属性生成的列名对应SQL SERVER列int类型；而String类型的属性则对应SQL SERVER列的NVARCHAR类型。若类的字符串类型属性未设置MaxLength，则生成对应的列类型为NVARCHAR(MAX)。 为属性指定对应的SQL SERVER数据类型： [Column(\"UnitPrice\", TypeName = \"MONEY\")] public decimal UnitPrice { get; set; } 重写OnModelCreating方法，配置类对应于数据库中的表名： protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().ToTable(\"Product\"); } modelBuilder.Entity().Property(t => t.UnitPrice) .HasColumnName(\"UnitPrice\") .HasColumnType(\"MONEY\"); 到此步，Product.cs类文件的完整代码如下： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; namespace Portal.Entities { [Table(\"Product\", Schema = \"dbo\")] public class Product { [Column(\"ProductID\")] public int ProductID { get; set; } [MaxLength(100)] [Required, Column(\"ProductName\")] public string ProductName { get; set; } [Column(\"UnitPrice\", TypeName = \"MONEY\")] public decimal UnitPrice { get; set; } } } 属性设置text数据类型： [Column(\"Remark\", TypeName = \"text\")] public string Remark { get; set; } modelBuilder.Entity().Property(t => t.Remark) .HasColumnName(\"Remark\") .HasColumnType(\"text\"); © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/section1/appendix3.html":{"url":"chapter3/section1/appendix3.html","title":"第三节 主键","keywords":"","body":"主键Data Annotation 方式Fluent API方式主键 Entity Framework Code First的默认主键约束：属性名为[ID]或[类名 + ID]。如在Product类中，Entity Framework Code First会根据默认约定将类中名称为ID或ProductID的属性设置为主键。Entity Framework Code First主键的默认约定也一样可以进行重写，重新根据需要进行设置。 Data Annotation 方式 using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; [Key] [Column(\"ProductID\")] public int ProductID { get; set; } Fluent API方式 protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().HasKey(t => t.ProductID); } 若一个表有多个主键时： protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().HasKey(t => new { t.KeyID, t.CandidateID }); }[Column(\"UnitPrice\", TypeName = \"MONEY\")] public decimal UnitPrice { get; set; } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/section1/appendix4.html":{"url":"chapter3/section1/appendix4.html","title":"第四节 数据库自动生成字段值","keywords":"","body":"数据库自动生成字段值Data Annotation 方式Fluent API方式数据库自动生成字段值 Entity Framework Code First对于int类型的主键，会自动的设置其为自动增长列。但有时我们确实不需是自动增长的，可以通过以下方式进行取消自动增长。 Data Annotation 方式 [Key] [Column(\"ProductID\")] [DatabaseGenerated(DatabaseGeneratedOption.None)] public int ProductID { get; set; } [Key] [Column(\"CategoryID\")] [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int CategoryID { get; set; } Fluent API方式 protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().HasKey(t => t.ProductID); modelBuilder.Entity().Property(t => t.ProductID) .HasColumnName(\"ProductID\") .HasDatabaseGeneratedOption(DatabaseGeneratedOption.None); } protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().HasKey(t => t.ProductID); modelBuilder.Entity().Property(t => t.ProductID) .HasColumnName(\"ProductID\") .HasDatabaseGeneratedOption(DatabaseGeneratedOption.None); } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/section1/appendix5.html":{"url":"chapter3/section1/appendix5.html","title":"第五节 数字类型长度及精度","keywords":"","body":"数字类型长度及精度数字类型长度及精度 在Product类中，UnitPrice表示单价，对于价格类的字段，我们通常会希望其保留2为小数。这时可以使用Fluent API进行设置，且Data Annotation不支持该设置。 protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().Property(t => t.UnitPrice) .HasColumnName(\"UnitPrice\") .HasPrecision(18, 2); } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/section1/appendix6.html":{"url":"chapter3/section1/appendix6.html","title":"第六节 非数据库字段属性","keywords":"","body":"非数据库字段属性Data Annotation 方式Fluent API 方式非数据库字段属性 在类中，如果有一些属性不需要映射到对应生成的数据表中，可以通过以下方式设置。 Data Annotation 方式 [NotMapped] public string Remark { get; set; } Fluent API 方式 protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Entity().Ignore(t => t.Remark); } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapter3/section1/appendix7.html":{"url":"chapter3/section1/appendix7.html","title":"第七节 Fluent API配置Configuration映射类","keywords":"","body":"Fluent API配置Configuration映射类ProductMap.cs类Fluent API配置Configuration映射类 在使用Fluent API进行Entity Framework Code First数据库映射时，除了以上的在重写OnModelCreating方法中直接对Entity进行配置之外，也可以对Configurations进行配置。这时可以先写一个单独的类，将数据表的全部映射要求都写在构造函数中。 ProductMap.cs类 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.ComponentModel.DataAnnotations.Schema; using System.Data.Entity.ModelConfiguration; using Portal.Entities; namespace Portal.Mapping { public class ProductMap : EntityTypeConfiguration { public ProductMap() { // Primary Key this.HasKey(t => t.ProductID); // Properties this.Property(t => t.ProductID) .HasDatabaseGeneratedOption(DatabaseGeneratedOption.None); this.Property(t => t.ProductName) .IsRequired() .HasMaxLength(100); // Table & Column Mappings this.ToTable(\"Product\"); this.Property(t => t.ProductID).HasColumnName(\"ProductID\"); this.Property(t => t.ProductName).HasColumnName(\"ProductName\"); this.Property(t => t.UnitPrice) .HasColumnName(\"UnitPrice\") .HasPrecision(18, 2); } } } 有了上面的映射类之后，在转换OnModelCreating方法中则可以直接调用映射类，从而减少了OnModelCreating方法的复杂度，同时也增强了代码维护的替代性。 protected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Configurations.Add(new ProductMap()); } © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"end/":{"url":"end/","title":"结束","keywords":"","body":"结束结束 © Tongji University all right reserved，File Modify: 2020-01-23 11:17:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}